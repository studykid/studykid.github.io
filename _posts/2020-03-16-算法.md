## 排序 不同的排序方式
### 快速排序
 ``` java
import java.util.Arrays;

/**
 * @author yugenhai
 */
public class QuickSort {


    public static void main(String[] args) {
        int[] arrays = {3, 4, 6, 1, 8, 2, 5, 10, 7, 9};
        quickSort(arrays, 0, arrays.length - 1);
        System.out.println(Arrays.toString(arrays));
    }


    /**
     * 快排
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort(int[] arr, int left, int right) {
        //声明一个数来存 基准数
        int pivot;
        //一直可以排序
        if (left < right) {
            //从小到大
            pivot = partition(arr, left, right);
            //一直递归处理左边的一堆数
            quickSort(arr, left, pivot - 1);
            //一直递归处理右边的一堆数
            quickSort(arr, pivot + 1, right);
        }

    }


    /**
     * 分片排序
     *
     * @param arr
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] arr, int left, int right) {
        //取一个参照数
        int key = arr[left];
        //一直可以排序
        while (left < right) {
            //第一次右边先走  右边往左边一步一步移动
            while (left < right && arr[right] >= key) {
                //右边向左一步
                right--;
            }
            //交换位置
            arr[left] = arr[right];
            //左边往右边走
            while (left < right && arr[left] <= key) {
                left++;
            }
            //交换位置
            arr[right] = arr[left];
        }
        //碰面了把参照数交给往右走的
        arr[left] = key;
        //返回左边的数
        return left;
    }
}
 ```
 #### 最差的时间复杂度和冒泡排序一样 O（n2） 平均复杂度 ONlogN
### 冒泡排序
### 堆排序
### 归并排序
 ``` java

import java.util.Arrays;

/**
 * @author yugenhai
 */
public class QuickSort {


    public static void main(String[] args) {
        int[] arrays = {3, 4, 6, 1, 8, 2, 5, 10, 7, 9};
        quickSort(arrays, 0, arrays.length - 1);
        System.out.println(Arrays.toString(arrays));
    }


    /**
     * 快排
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort(int[] arr, int left, int right) {
        //声明一个数来存 基准数
        int pivot;
        //一直可以排序
        if (left < right) {
            //从小到大
            pivot = partition(arr, left, right);
            //一直递归处理左边的一堆数
            quickSort(arr, left, pivot - 1);
            //一直递归处理右边的一堆数
            quickSort(arr, pivot + 1, right);
        }

    }


    /**
     * 分片排序
     *
     * @param arr
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] arr, int left, int right) {
        //取一个参照数
        int key = arr[left];
        //一直可以排序
        while (left < right) {
            //第一次右边先走  右边往左边一步一步移动
            while (left < right && arr[right] >= key) {
                //右边向左一步
                right--;
            }
            //交换位置
            arr[left] = arr[right];
            //左边往右边走
            while (left < right && arr[left] <= key) {
                left++;
            }
            //交换位置
            arr[right] = arr[left];
        }
        //碰面了把参照数交给往右走的
        arr[left] = key;
        //返回左边的数
        return left;
    }
}
 ```
 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

## 链表 能否从头写出一个链表 插入 删除 搜索的复杂度 

## 哈希 什么是哈希函数 什么是哈希冲突 如何解决 平均复杂度 最坏情况复杂度 

## 二叉树 什么是二叉树从头到尾写一个二叉树 搜索插入 删除的复杂度 平衡树意味着什么 复杂度是多少

## 动态编程是什么 怎么用 解决什么问题

## 图的遍历算法 你能从头到尾写一个图数据结构吗 什么时候用图 修改图有哪些不同的方法
