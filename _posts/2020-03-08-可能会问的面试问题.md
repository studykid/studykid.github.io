## spring 里的aop是什么意思
将相同逻辑的重复代码提取出来，使用动态代理技术将这些重复的代码织入目标对象方法中。实现和原来一样的功能。
spring里的aop就是切面编程的意思，spring 用代理增强了类。来实现一些事务 日志之类的功能。

## spring mvc的思想和原理
mvc是一种设计思想，按照模型 视图 控制器 进行划分。模型用来封装业务逻辑，试图用来表现逻辑，控制器用来协调模型和视图。
1 请求到 dispatcherservlet
2 根据信息调用handlermapping 解析相对应的handler
3 解析到handler后会根据handler调用真正的处理器来处理请求，处理想对应的业务
4 处理器处理完业务会返回一个modeandview 
5 viewresolver 会根据逻辑viwe查找实际的view 
6 dispaterServlet 把返回的model 传给view 
7 把view 返回请求者

## 事务的传播行为
一般用required 意思是调用这个service层里面的其他方法时 如果当前方法产生了事务 就用当前方法产生的事务。否则创建一个新的事务。


## rabbitmq 是用来做什么的？怎么防止数据丢失？怎么处理重复数据？怎么保证数据的一致性？
rabbitmq 有时特定时间订单比较多 是用来消峰的，
rabbitmq的好处 解耦 ，异步 提高响应速度 ，消峰。
10、如何确保消息正确地发送至RabbitMQ？

RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

 
11、如何确保消息接收方消费了消息？

接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。

下面罗列几种特殊情况：

    如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
    如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

12、如何避免消息重复投递或重复消费？

在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。

这个问题针对业务场景来答分以下几点：

1.比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。

2.再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。

3.如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<id,message>以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。
 
13、如何解决丢数据的问题?

1.生产者丢数据

生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。

transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。

然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

2.消息队列丢数据

处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步

①、将queue的持久化标识durable设置为true,则代表是一个持久的队列

②、发送消息的时候将deliveryMode=2

这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）

3.消费者丢数据

启用手动确认模式可以解决这个问题

①自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。

②手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。

③不确认模式，acknowledge="none" 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。

## redis用来存放什么数据的
我们用来存放用户的token 和商品的库存

## 怎么保证redis的事务 以及redis 和数据库的一致性。

## 怎么保证redis的高可用 
我们用的主从架构

## netty？？
BIO, The synchronous blocking IO, simple to understand: a connection to a thread
NIO, Synchronous non blocking IO, simple to understand: a request a thread
AIO, Asynchronous non blocking IO, simple to understand: a valid request a thread
BIO
Before JDK1.4, written by Java network request, is the establishment of a ServerSocket, then, the client establishes Socket will ask if there are threads can process, if not, either wait for, or rejected. Namely: a connection request, Server corresponds to a processing thread.

NIO
Origin in Java, in the JDK1.4 and later provides a set of API to operate non blocking I/O, we can find the related classes and interfaces in the java.nio package and its subpackages. Because of this API is JDK new I/O API, therefore, also called New I/O, which is the origin of the package name NiO. The API consists of three main parts: buffer (Buffers), channel (Channels) formed the core class and non blocking I/O. The need to distinguish between when, understanding of NIO, say New I/O or non blocking IO, New I/O is the Java package, NIO is a non blocking IO concept. Here is a back.

The NIO itself is based on the idea of event driven to complete, mainly to solve the complicated problem of BIO is: in the network application using I/O, if you want to handle multiple client requests, or on the client to communicate with multiple servers, you must use multiple threads to process. That is to say, every client request is assigned to a thread separate processing. Although it can meet our requirements, but also bring another problem. Because each create a thread, will be allocated a certain amount of memory space for the thread (also called working memory), and the operating system itself but also on the total number of threads that have certain limitations. If the client requests the server program too much, may be because of heavy and refused the request of the client, and the server may therefore paralysis.

NIO based on the Reactor, when the socket flow readable or writable socket, operating system will be the corresponding notification reference procedure, application of the current read into the buffer or write operating system. 
That is to say, this time, is not a connection to a corresponding processing threads, but a valid request, corresponding to a thread, when the connection is used when there is no data, there is no a worker thread to handle.

AIO
Unlike NIO, when the read and write operation, can only directly call API read or write method. These two methods are asynchronous, for a read operation, when the stream can be read, the operating system will spread into the read buffer method and readable, and notify the application; for a write operation, when the operating system will write transmission stream to write is completed, the operating system to inform application program. 
That can be understood as, read/write methods are asynchronous, after completion will take the initiative to call the callback function. 
In JDK1.7, this part is called NIO.2, mainly in the java.nio.channels package adds the following four asynchronous channels:

AsynchronousSocketChannel
AsynchronousServerSocketChannel
AsynchronousFileChannel
AsynchronousDatagramChannel
The read/write method among them, will return with a callback object, when the execution of the read / write operation, direct calls the callback function.

The realization principle
Said the realization of the principle, but also from the IO model on an understanding of the operating system

In accordance with the "division" Unix network programming, IO model can be divided into: blocking IO, non blocking IO, IO multiplexing, signal driving IO and asynchronous IO, in accordance with the POSIX standard to divided only into two categories: synchronous and asynchronous IO IO. How to distinguish? First of all a IO operation is divided into two steps: IO request and IO operations, The difference between synchronous and asynchronous IO IO lies in the second steps is blocking, If the actual IO read and write blocking request process, So is the synchronization of IO, Therefore, blocking IO, non blocking IO, IO multiplexing, signal driving IO are synchronous IO, If no obstruction, But the operating system to help you finish the IO operation and return the results to you, It is the asynchronous IO. The difference between IO and non blocking IO lies in the first step, IO request will be blocked, if block until complete blocking IO it is traditional, if not blocked, it is non blocking IO.

Received IO model operating system, also have to mention select/poll/epoll/iocp, about the four understanding, not do more to explain, you still do not understand the place.

Can understand the explanation is: in Linux 2.6, Java NIO, is achieved through the epoll, this can be found by JDK source code. AIO, on the windows is realized by IOCP, in the Linux or epoll to achieve through.

Here to emphasize one point: AIO, this is I/O processing mode, and epoll is a realization of AIO programming model; in other words, AIO is an interface standard, the operating system can be achieved or not achieved. In different operating system in the high complicated circumstances are the best recommended operating system. No Linux to achieve real network AIO.

The underlying basis
When it comes to the bottom, say Linux system programming, here do not familiar with, to be later added. 
Only the general said a: AIO

In windows, the AIO is achieved through IOCP, see the JDK source code, can be found

WindowsAsynchronousSocketChannelImpl

Realization of interface:

implements Iocp.OverlappedChannel

Look at the implementation method: read0/write0 method is the native method, call the JVM implementation, the virtual machine technology is not familiar with, don't you.

In Linux, the AIO is achieved through epoll, see the JDK source code, can be found, the source code is:

UnixAsynchronousSocketChannelImpl

Realization of interface:

implements Port.PollableChannel

This is the difference between a and windows maximum, poll, in linux2.6, use the default epoll.

So you can understand.

Written in the last: Java development based, for the operating system underlying cognitive is not C based language is good, language determines the mode of thinking, the ancients did not cheat me

Finally, several papers explain the good article:

BIO NIO AIO
