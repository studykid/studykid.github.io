## spring 里的aop是什么意思
将相同逻辑的重复代码提取出来，使用动态代理技术将这些重复的代码织入目标对象方法中。实现和原来一样的功能。
spring里的aop就是切面编程的意思，spring 用代理增强了类。来实现一些事务 日志之类的功能。

## spring mvc的思想和原理
mvc是一种设计思想，按照模型 视图 控制器 进行划分。模型用来封装业务逻辑，试图用来表现逻辑，控制器用来协调模型和视图。
1 请求到 dispatcherservlet
2 根据信息调用handlermapping 解析相对应的handler
3 解析到handler后会根据handler调用真正的处理器来处理请求，处理想对应的业务
4 处理器处理完业务会返回一个modeandview 
5 viewresolver 会根据逻辑viwe查找实际的view 
6 dispaterServlet 把返回的model 传给view 
7 把view 返回请求者


## rabbitmq 是用来做什么的？怎么防止数据丢失？怎么处理重复数据？怎么保证数据的一致性？
rabbitmq 有时特定时间订单比较多 是用来消峰的，

## redis用来存放什么数据的
我们用来存放用户的token 和商品的库存

## 怎么保证redis的事务 以及redis 和数据库的一致性。

## 怎么保证redis的高可用 
我们用的主从架构

## netty？？
BIO, The synchronous blocking IO, simple to understand: a connection to a thread
NIO, Synchronous non blocking IO, simple to understand: a request a thread
AIO, Asynchronous non blocking IO, simple to understand: a valid request a thread
BIO
Before JDK1.4, written by Java network request, is the establishment of a ServerSocket, then, the client establishes Socket will ask if there are threads can process, if not, either wait for, or rejected. Namely: a connection request, Server corresponds to a processing thread.

NIO
Origin in Java, in the JDK1.4 and later provides a set of API to operate non blocking I/O, we can find the related classes and interfaces in the java.nio package and its subpackages. Because of this API is JDK new I/O API, therefore, also called New I/O, which is the origin of the package name NiO. The API consists of three main parts: buffer (Buffers), channel (Channels) formed the core class and non blocking I/O. The need to distinguish between when, understanding of NIO, say New I/O or non blocking IO, New I/O is the Java package, NIO is a non blocking IO concept. Here is a back.

The NIO itself is based on the idea of event driven to complete, mainly to solve the complicated problem of BIO is: in the network application using I/O, if you want to handle multiple client requests, or on the client to communicate with multiple servers, you must use multiple threads to process. That is to say, every client request is assigned to a thread separate processing. Although it can meet our requirements, but also bring another problem. Because each create a thread, will be allocated a certain amount of memory space for the thread (also called working memory), and the operating system itself but also on the total number of threads that have certain limitations. If the client requests the server program too much, may be because of heavy and refused the request of the client, and the server may therefore paralysis.

NIO based on the Reactor, when the socket flow readable or writable socket, operating system will be the corresponding notification reference procedure, application of the current read into the buffer or write operating system. 
That is to say, this time, is not a connection to a corresponding processing threads, but a valid request, corresponding to a thread, when the connection is used when there is no data, there is no a worker thread to handle.

AIO
Unlike NIO, when the read and write operation, can only directly call API read or write method. These two methods are asynchronous, for a read operation, when the stream can be read, the operating system will spread into the read buffer method and readable, and notify the application; for a write operation, when the operating system will write transmission stream to write is completed, the operating system to inform application program. 
That can be understood as, read/write methods are asynchronous, after completion will take the initiative to call the callback function. 
In JDK1.7, this part is called NIO.2, mainly in the java.nio.channels package adds the following four asynchronous channels:

AsynchronousSocketChannel
AsynchronousServerSocketChannel
AsynchronousFileChannel
AsynchronousDatagramChannel
The read/write method among them, will return with a callback object, when the execution of the read / write operation, direct calls the callback function.

The realization principle
Said the realization of the principle, but also from the IO model on an understanding of the operating system

In accordance with the "division" Unix network programming, IO model can be divided into: blocking IO, non blocking IO, IO multiplexing, signal driving IO and asynchronous IO, in accordance with the POSIX standard to divided only into two categories: synchronous and asynchronous IO IO. How to distinguish? First of all a IO operation is divided into two steps: IO request and IO operations, The difference between synchronous and asynchronous IO IO lies in the second steps is blocking, If the actual IO read and write blocking request process, So is the synchronization of IO, Therefore, blocking IO, non blocking IO, IO multiplexing, signal driving IO are synchronous IO, If no obstruction, But the operating system to help you finish the IO operation and return the results to you, It is the asynchronous IO. The difference between IO and non blocking IO lies in the first step, IO request will be blocked, if block until complete blocking IO it is traditional, if not blocked, it is non blocking IO.

Received IO model operating system, also have to mention select/poll/epoll/iocp, about the four understanding, not do more to explain, you still do not understand the place.

Can understand the explanation is: in Linux 2.6, Java NIO, is achieved through the epoll, this can be found by JDK source code. AIO, on the windows is realized by IOCP, in the Linux or epoll to achieve through.

Here to emphasize one point: AIO, this is I/O processing mode, and epoll is a realization of AIO programming model; in other words, AIO is an interface standard, the operating system can be achieved or not achieved. In different operating system in the high complicated circumstances are the best recommended operating system. No Linux to achieve real network AIO.

The underlying basis
When it comes to the bottom, say Linux system programming, here do not familiar with, to be later added. 
Only the general said a: AIO

In windows, the AIO is achieved through IOCP, see the JDK source code, can be found

WindowsAsynchronousSocketChannelImpl

Realization of interface:

implements Iocp.OverlappedChannel

Look at the implementation method: read0/write0 method is the native method, call the JVM implementation, the virtual machine technology is not familiar with, don't you.

In Linux, the AIO is achieved through epoll, see the JDK source code, can be found, the source code is:

UnixAsynchronousSocketChannelImpl

Realization of interface:

implements Port.PollableChannel

This is the difference between a and windows maximum, poll, in linux2.6, use the default epoll.

So you can understand.

Written in the last: Java development based, for the operating system underlying cognitive is not C based language is good, language determines the mode of thinking, the ancients did not cheat me

Finally, several papers explain the good article:

BIO NIO AIO
