# 1、TCP、UDP的区别？
tcp是面向连接的 udp是面向无链接的。
建立连接指的是 在客户端和服务端维护连接 而建立一定的数据结构来维护相互的状态。
tcp 提供可靠交付 udp不保证不丢失 不保证按顺序到达
tcp 是面向字节流的 udp继承了ip的特性。基于数据报 一个一个发 一个一个收
tcp是拥有阻塞控制的。udp则不会
tcp是有状态的 udp则不会

tcp是可靠传输 udp是不可靠的。tcp是一对一 udp是一对多的
# telnet和ping 有什么区别

# 2、TCP协议如何保证可靠传输？
tcp包头
|  源端口号   | 目的端口号  |
|  ----  | ----  |
|序号|
|确认序号|
|首部长度|保留6位|URG|ACK|PSH|RST|SYN|FIN|窗口大小|
| 校验和16  | 紧急指针 |
|选项|
|数据|

# 3、TCP的握手、挥手机制？
三次握手 四次挥手


# Netty的特点？

一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持
使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。
采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理
可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持
可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf
通过引用计数器及时申请释放不再引用的对象，降低了GC频率
使用单线程串行化的方式，高效的Reactor线程模型
大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用
# 4、TCP的粘包/拆包原因及其解决方法是什么？

# 5、Netty的粘包/拆包是怎么处理的，有哪些实现？
# 6、同步与异步、阻塞与非阻塞的区别？
# 7、说说网络IO模型？
# 8、BIO、NIO、AIO分别是什么？
## netty？？
BIO, The synchronous blocking IO, simple to understand: a connection to a thread
NIO, Synchronous non blocking IO, simple to understand: a request a thread
AIO, Asynchronous non blocking IO, simple to understand: a valid request a thread
BIO
Before JDK1.4, written by Java network request, is the establishment of a ServerSocket, then, the client establishes Socket will ask if there are threads can process, if not, either wait for, or rejected. Namely: a connection request, Server corresponds to a processing thread.

NIO
Origin in Java, in the JDK1.4 and later provides a set of API to operate non blocking I/O, we can find the related classes and interfaces in the java.nio package and its subpackages. Because of this API is JDK new I/O API, therefore, also called New I/O, which is the origin of the package name NiO. The API consists of three main parts: buffer (Buffers), channel (Channels) formed the core class and non blocking I/O. The need to distinguish between when, understanding of NIO, say New I/O or non blocking IO, New I/O is the Java package, NIO is a non blocking IO concept. Here is a back.

The NIO itself is based on the idea of event driven to complete, mainly to solve the complicated problem of BIO is: in the network application using I/O, if you want to handle multiple client requests, or on the client to communicate with multiple servers, you must use multiple threads to process. That is to say, every client request is assigned to a thread separate processing. Although it can meet our requirements, but also bring another problem. Because each create a thread, will be allocated a certain amount of memory space for the thread (also called working memory), and the operating system itself but also on the total number of threads that have certain limitations. If the client requests the server program too much, may be because of heavy and refused the request of the client, and the server may therefore paralysis.

NIO based on the Reactor, when the socket flow readable or writable socket, operating system will be the corresponding notification reference procedure, application of the current read into the buffer or write operating system. 
That is to say, this time, is not a connection to a corresponding processing threads, but a valid request, corresponding to a thread, when the connection is used when there is no data, there is no a worker thread to handle.

AIO
Unlike NIO, when the read and write operation, can only directly call API read or write method. These two methods are asynchronous, for a read operation, when the stream can be read, the operating system will spread into the read buffer method and readable, and notify the application; for a write operation, when the operating system will write transmission stream to write is completed, the operating system to inform application program. 
That can be understood as, read/write methods are asynchronous, after completion will take the initiative to call the callback function. 
In JDK1.7, this part is called NIO.2, mainly in the java.nio.channels package adds the following four asynchronous channels:

AsynchronousSocketChannel
AsynchronousServerSocketChannel
AsynchronousFileChannel
AsynchronousDatagramChannel
The read/write method among them, will return with a callback object, when the execution of the read / write operation, direct calls the callback function.

The realization principle
Said the realization of the principle, but also from the IO model on an understanding of the operating system

In accordance with the "division" Unix network programming, IO model can be divided into: blocking IO, non blocking IO, IO multiplexing, signal driving IO and asynchronous IO, in accordance with the POSIX standard to divided only into two categories: synchronous and asynchronous IO IO. How to distinguish? First of all a IO operation is divided into two steps: IO request and IO operations, The difference between synchronous and asynchronous IO IO lies in the second steps is blocking, If the actual IO read and write blocking request process, So is the synchronization of IO, Therefore, blocking IO, non blocking IO, IO multiplexing, signal driving IO are synchronous IO, If no obstruction, But the operating system to help you finish the IO operation and return the results to you, It is the asynchronous IO. The difference between IO and non blocking IO lies in the first step, IO request will be blocked, if block until complete blocking IO it is traditional, if not blocked, it is non blocking IO.

Received IO model operating system, also have to mention select/poll/epoll/iocp, about the four understanding, not do more to explain, you still do not understand the place.

Can understand the explanation is: in Linux 2.6, Java NIO, is achieved through the epoll, this can be found by JDK source code. AIO, on the windows is realized by IOCP, in the Linux or epoll to achieve through.

Here to emphasize one point: AIO, this is I/O processing mode, and epoll is a realization of AIO programming model; in other words, AIO is an interface standard, the operating system can be achieved or not achieved. In different operating system in the high complicated circumstances are the best recommended operating system. No Linux to achieve real network AIO.

The underlying basis
When it comes to the bottom, say Linux system programming, here do not familiar with, to be later added. 
Only the general said a: AIO

In windows, the AIO is achieved through IOCP, see the JDK source code, can be found

WindowsAsynchronousSocketChannelImpl

Realization of interface:

implements Iocp.OverlappedChannel

Look at the implementation method: read0/write0 method is the native method, call the JVM implementation, the virtual machine technology is not familiar with, don't you.

In Linux, the AIO is achieved through epoll, see the JDK source code, can be found, the source code is:

UnixAsynchronousSocketChannelImpl

Realization of interface:

implements Port.PollableChannel

This is the difference between a and windows maximum, poll, in linux2.6, use the default epoll.

So you can understand.

Written in the last: Java development based, for the operating system underlying cognitive is not C based language is good, language determines the mode of thinking, the ancients did not cheat me

Finally, several papers explain the good article:

BIO NIO AIO
# 9、select、poll、epoll的机制及其区别？
https://www.cnblogs.com/aspirant/p/9166944.html
# 10、说说你对Netty的了解？
# 11、Netty跟Java NIO有什么不同，为什么不直接使用JDK NIO类库？
# 12、Netty组件有哪些，分别有什么关联？

# 13、说说Netty的执行流程？
1、创建ServerBootStrap实例

2、设置并绑定Reactor线程池：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel

3、设置并绑定服务端的channel

4、5、创建处理网络事件的ChannelPipeline和handler，网络时间以流的形式在其中流转，handler完成多数的功能定制：比如编解码 SSl安全认证

6、绑定并启动监听端口

7、当轮训到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler 
# 14、Netty高性能体现在哪些方面？

# 15、Netty的线程模型是怎么样的？

[thread model]( https://www.jianshu.com/p/738095702b75)
[thread model]( https://blog.csdn.net/memery_last/article/details/83757711)
[thread model](https://www.lagou.com/lgeduarticle/15654.html)




# 16、Netty的零拷贝提体现在哪里，与操作系统上的有什么区别？

# 17、Netty的内存池是怎么实现的？
[内存池](https://www.jianshu.com/p/8d894e42b6e6)

# 18、Netty的对象池是怎么实现的？
[对象池](https://www.jianshu.com/p/b6bd21056d0f)
# 19、在实际项目中，你们是怎么使用Netty的？
# 20、使用过Netty遇到过什么问题？
