# SQL
## group by 要注意什么？
## 100万的大表和1万的小表查询 怎么查询。
select from A where B not exist（selcet from b where ）;

## 加索引的时候要注意什么 ？索引失效了怎么办？
表不能加太多的索引，索引失效可能是sql语句有问题，

## 事务的隔离级别有哪些？你们用的是哪些？
事务的隔离级别有四中 未提交读 脏读 不可重复读 幻读 都不行。 提交读 可以防止脏读 是mysql默认的隔离级别。可重读读可以防止脏读 不可重读 是oracle的默认级别
串行化 最强的隔离级别。可以防止脏读 不可重复读 幻读。

## 索引需要注意什么
从功能上说 索引主要有四种，分别是普通索引，唯一索引，主键索引，和全文索引，多个索引还会增加索引选择时间
物理实现方式有聚集索引和非聚集索引
联合索引的最左匹配原则
索引的缺点 占用存储空间 降低数据库写操作性能
数据重复度高不需要创建索引
对索引的位置 比如我们你在where子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效。
当你知道只有一条记录的时候 可以使用limit1

在表中建立索引，优先考虑where、group by使用到的字段。
尽量避免使用select *，返回无用的字段会降低查询效率。如下：

SELECT * FROM t 

优化方式：使用具体的字段代替*，只返回使用到的字段。

 
尽量避免使用in 和not in，会导致数据库引擎放弃索引进行全表扫描。如下：

SELECT * FROM t WHERE id IN (2,3)

SELECT * FROM t1 WHERE username IN (SELECT username FROM t2)

优化方式：如果是连续数值，可以用between代替。如下：

SELECT * FROM t WHERE id BETWEEN 2 AND 3

如果是子查询，可以用exists代替。如下：

SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t1.username = t2.username)

尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。如下：

SELECT * FROM t WHERE id = 1 OR id = 3

优化方式：可以用union代替or。如下：

SELECT * FROM t WHERE id = 1
UNION
SELECT * FROM t WHERE id = 3

（PS：如果or两边的字段是同一个，如例子中这样。貌似两种方式效率差不多，即使union扫描的是索引，or扫描的是全表）

 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如下
SELECT * FROM t WHERE username LIKE '%li%'

优化方式：尽量在字段后面使用模糊查询。如下：

SELECT * FROM t WHERE username LIKE 'li%'

尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：

SELECT * FROM t WHERE score IS NULL

优化方式：可以给字段添加默认值0，对0值进行判断。如下：

SELECT * FROM t WHERE score = 0

 尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。如下：

SELECT * FROM t2 WHERE score/10 = 9

SELECT * FROM t2 WHERE SUBSTR(username,1,2) = 'li'

优化方式：可以将表达式、函数操作移动到等号右侧。如下：

SELECT * FROM t2 WHERE score = 10*9

SELECT * FROM t2 WHERE username LIKE 'li%'

当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：

SELECT * FROM t WHERE 1=1

优化方式：用代码拼装sql时进行判断，没where加where，有where加and



8. 避免使用子查询，可以把子查询优化为 join 操作

通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。

子查询性能差的原因：

子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。
9. 避免使用 JOIN 关联太多的表

对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。

在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。

如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。

同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。

21条MySQL性能调优经验

    为查询缓存优化你的查询EXPLAIN你的SELECT查询当只要一行数据时使用LIMIT 1为搜索字段建索引在Join表的时候使用相当类型的例，并将其索引千万不要 ORDER BY RAND()避免 SELECT *永远为每张表设置一个 ID使用 ENUM 而不是 VARCHAR从 PROCEDURE ANALYSE() 取得建议尽可能的使用 NOT NULLPrepared Statements无缓冲的查询把 IP 地址存成 UNSIGNED INT固定长度的表会更快垂直分割拆分大的 DELETE 或 INSERT 语句越小的列会越快选择正确的存储引擎使用一个对象关系映射器(Object Relational Mapper)小心“永久链接”
# MySql
##  数据库的三范式是什么？
##  一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？
##  如何获取当前数据库版本？
##  说一下 ACID 是什么？
##  char 和 varchar 的区别是什么？
##  float 和 double 的区别是什么？
##  mysql 的内连接、左连接、右连接有什么区别？
##  mysql 索引是怎么实现的？
##  怎么验证 mysql 的索引是否满足需求？
##  说一下数据库的事务隔离？
##  说一下 mysql 常用的引擎？
##  说一下 mysql 的行锁和表锁？
##  说一下乐观锁和悲观锁？
##  mysql 问题排查都有哪些手段？
##  如何做 mysql 的性能优化？


redis
能说说redis集群的原理吗？如果说依靠哨兵可以实现redis的⾼可⽤，如果还想在⽀持⾼并发同时容纳海量的数据，那就需要redis集 群。redis集群是redis提供的分布式数据存储⽅案，集群通过数据分⽚sharding来进⾏数据的共享，同 时提供复制和故障转移的功能。 节点 ⼀个redis集群由多个节点node组成，⽽多个node之间通过cluster meet命令来进⾏连接，节点的握⼿ 过程：

节点A收到客户端的cluster meet命令
A根据收到的IP地址和端⼝号，向B发送⼀条meet消息
节点B收到meet消息返回pong
A知道B收到了meet消息，返回⼀条ping消息，握⼿成功
最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进⾏ 握⼿ 槽slot redis通过集群分⽚的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处 理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有⼀个slot没 有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。 slot是⼀个位数组，数组的⻓度是16384/8=2048，⽽数组的每⼀位⽤1表示被节点处理，0表示不处理， 如图所示的话表示A节点处理0-7的slot。 当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执⾏命令，反之，则会返回⼀个 MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是⾃动的）如果增加或者移出节点，对于slot的重新分配也是⾮常⽅便的，redis提供了⼯具帮助实现slot的迁移，整 个过程是完全在线的，不需要停⽌服务。 故障转移 如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail 疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为 pfail状态，B就会被标记为fail下线状态，此时将会发⽣故障转移，优先从复制数据较多的从节点选择⼀ 个成为主节点，并且接管下线节点的slot，整个过程和哨兵⾮常类似，都是基于Raft协议做选举。
